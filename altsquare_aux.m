/* 
    sp_aux.m                                                                      RecogniseSmallDim

    This file contains some auxiliary functions necessary for the recognition of exterior squares of 
    for Sp(n,q).

    Written by Csaba Schneider.
    Analysed in February 2024
*/

import "smalldimreps.m":funcpos_altsquare, SolveAltSquareDimEq, __funcAltSquareToSLdq, __funcSLdqToAltSquare;

/* 
    This file contains some auxiliary functions that are necessary for the recognition of the exterior square 
    representations, especially in the case of the symplectic groups. 

    Suppose that M is the large irreducible factor of the exterior square of V where V is the natural module for the 
    symplectic group. Suppose that V = U + W is a decomposition of V into the direct sum of non-degenerate subspaces 
    and also assume that the characteristic p does not divide dim U and dim V. Suppose that C is the 
    stabilizer of the decomposition, and so C = Sp(U) x Sp(W).

    If the characteristic p does not devide dim V, then 

    M = H + K + T + W

    where H and K are the large irreducible quotients of Lambda^2 U and Lambda^2 W, respectively and T = U tensor W. 
    Furthermore, H + W = Lambda^2 U and K + W = Lambda^2 W.

    if p divides dim V, then 

    M = H + K + W

    where H and K are the large irreducible quotients of Lambda^2 U and Lambda^2 W, respectively and T = U tensor W.

*/


/*
    Suppose that n = d1+d2, e1,...,en are the standard row basis vectors of F^n. This function builds a matrix whise rows are 
    
    e1-ed1, e2-ed1, ...,e{d1-1}-ed1, e1+e2+...+ed1      and 
    e{d1+1}-en, e{d1+2}-edn, ...,e{n-1}-en, e{d1+1}+e{d1+2}+...+en.
    
    This is used when e1, e2, etc, represent e1f1, e2f2, ..., enfn and the natural module V is decomposed into components of dimension 
    d1 and d2.
*/


SpTransformMatrix := function( d1, d2, F )
    
    d := d1+d2;
    assert IsEven( d );
    dd1 := d1 div 2; dd2 := d2 div 2; dd := d div 2;
    
    M := ZeroMatrix( F, d div 2, d div 2 );
    
    for i in [1..dd1-1] do
        M[i,i] := 1; M[i,dd1] := -1;
    end for;
    
    for i in [1..dd1] do
        M[dd1,i] := 1;
    end for;
    
    for i in [1..dd2-1] do
        M[dd1+i,dd1+i] := 1; M[dd1+i,dd] := -1;
    end for;
    
    for i in [1..d2 div 2] do
        M[dd,(dd1 + i)] := 1;
    end for;
    
    return M;
end function; 
    
/* 
    Returns the vector space generated by the rows of the matrix in the previous function.

    If pdividesd is true, then returns the vector space generated by the 
    first d1/2 - 1 elemenets
    the elements with index d1/2+1 to d, and 
    the sum of the d1/2 and d/2 entry.
*/

SpSubspace := function( d1, d2, F : pdividesd := false )    

    d := d1 + d2;
    dd1 := d1 div 2; dd2 := d2 div 2; dd := d div 2;
    mat := SpTransformMatrix( d1, d2, F );
    V := VectorSpace( F, dd );
    if pdividesd then
        return VectorSpaceWithBasis( mat[1..dd1-1] cat mat[dd1+1..dd-1] cat [ mat[dd1]+mat[dd]]);
    else  
        return VectorSpaceWithBasis( mat );
    end if;

end function;
    
/* 
   Builds standard basis for V in the case of sympectic groups acting on the exterior square. 
   We assume that V = U + W and we have standard bases for H = U wedge U, K = W wedge W, and for T = U tensor W. 
   We can also pass on optional argument scalars which specifies a scalar factors and wH which specifies  
*/
            

/* TODO: This can be replaced by a single matrix multiplication. If there was a function to build the bases of H, K, T, then 
   this computation can be done by computing this basis matrix, inverting it, and multiplying the input with this inverted matrix. */

BuildBasisSp := function( basH, basK, basT : wH, scalars := [1,1,1,1] )

    a := scalars[1]; b := scalars[2]; c := scalars[3]; d := scalars[4]; 
    
    V := Parent( basH[1] ); ZV := Zero( V );
    q := #Field( V );
    _, p := IsPrimePower( q );
    
    // first multiply the bases with the respective scalars
    for v in [1..#basH] do
        basH[v] *:= a;
    end for;
    
    for v in [1..#basK] do
        basK[v] *:= b;
    end for;
    
    for v in [1..#basT] do
        basT[v] *:= c;
    end for;
    
    if not Category( wH ) eq BoolElt then
        wH *:= d;
    end if;
        
    // calculate the dimensions of H and K
    dH := SolveAltSquareDimEq( #basH : type := "Sp" ); 
    dK := SolveAltSquareDimEq( #basK : type := "Sp" );
    d := dH + dK;
    
    // divide dimensions by 2
    dd := d div 2; ddH := dH div 2; ddK := dK div 2;

    // check if p divides the dimension
    pdividesd := d mod p eq 0;

    // calculate the total dimension and an array to hold the basis
    dim := case< pdividesd | true: dd*(d-1) - 2, default: dd*(d-1) -1 >;
    bas := [ Zero( Parent( basH[1] )) : _ in [1..dim] ];

    /* 
       we think of the spaces H and K to be spaced as 
       e1,...,ed,e{d+1},...,en,fn,...,f{d+1},fd,...,f1
       where H is <e_1,...,ed,fd,...,f1>, while K is <e{d+1},...,en,fn,...,f{d+1}>
       we calculate the indices for the basis vectors that belong to H and K.
    */

    rangeH := [1..ddH] cat [ddH+dK+1..d]; rangeK := [ddH+1..ddH+dK];

    /* 
      We generate the subspace that corresponds to 
      e1f1 - edfd, ..., e{d-1}f{d-1}, 
      (*) e1f1+e2f2+...+edfd
      e{d+1}f{d+1}-enfn,...,e{n-1}f{n-1}-enfn, 
      (*) e{d+1}f{d+1}+...+enfn

      if pdividesd then the two basis elements with (*) are omitted and 
      e1f1+...+enfn is added in the last position.
    */
    
    subsp := SpSubspace( dH, dK, GF( q ) : pdividesd := pdividesd );

    // we create the list of basis elements from basH that are of the form 
    // e1f1-edfd, ..., e{d-1}f{d-1}-edfd 
    vecs_ex := [ basH[ funcpos_altsquare( dH, i, dH-i+1 : type := "Sp" )] : i in [1..ddH-1]];
    
    // if not pdividesd then we add the generator of wH which corresponds to
    // e1f1+...+edfd 
    if not pdividesd then
        Append( ~vecs_ex, wH );
    end if;
    
    // we add the basis elements e{d+1}f{d+1}-enfn
    vecs_ex := vecs_ex cat [ basK[ funcpos_altsquare( dK, i, dK-i+1 : type := "Sp" )] : i in [1..ddK-1]];
    
    // if needed we add -wH which corresponds to e{d+1}f{d+1}+...+enfn
    if not pdividesd then
        Append( ~vecs_ex, -wH );
    else
        // otherwise we full up the list with two instances of the zero vector
        vecs_ex := vecs_ex cat [ ZV, ZV ];
    end if;
    
    // V0 represents the vector space generated by the e1f1,...,enfn
    V0 := VectorSpace( GF( q ), dd ); ZV0 := Zero( V0 );

    // we build up the basis for V from the bases in the input
    // the indices run for 1 <= i < j <= d
    for i in [1..d], j in [i+1..d] do
        i0 := i; j0 := j;
        // the basis element enfn skipped
        if i0 eq dd and j0 eq dd+1  then
            continue j;
        end if;

        // the first option is when the corresponding basis element comes from H
        if i0 in rangeH and j0 in rangeH then
                
            // Since K is inserted into the middle of H, i0 and j0 has to be offset if they 
            // represent fi    
            if i0 gt ddH then i0 -:= dK; end if;
            if j0 gt ddH then j0 -:= dK; end if;

            // if the basis element <i0,j0> is not eifi-enfn    
            if i0+j0 ne dH+1 then
                // get the corresponding vector from basH
                vec := basH[ funcpos_altsquare( dH, i0, j0 : type := "Sp" )];
                // put it into the right place in bas
                bas[ funcpos_altsquare( d, i, j : type := "Sp" )] := vec;    
            else  
                // the vector to be treated is of the type eifi - enfn
                // we need to write it as a linear combination of the basis vectors of basH and basK
                // first we build this vector                 
                vec := ZV0; vec[i0] := 1; vec[dd] := -1;
                // compute its coeffs in the basis of subsp
                vec := Coordinates( subsp, vec );
                // if pdividesd then we append a zero
                if pdividesd then Append( ~vec, 0 ); end if;
                // take the linear combination of the elements in vecs_ex with these coefficients
                vec := &+[ vec[i]*vecs_ex[i] : i in [1..dd]];
                // insert into the right position
                bas[ funcpos_altsquare( d, i, j : type := "Sp" )] := vec;                    
            end if;
        
        // the next option is when i0, j0 represent a vector in K
        elif i0 in rangeK and j0 in rangeK then
                
            // we calculate the position relative to K
            i0 -:= ddH; j0 -:= ddH;


            if i0 + j0 ne dK +1 then   
                // when the vector is not of the form eifi - enfn 
                vec := basK[ funcpos_altsquare( dK, i0, j0 : type := "Sp" )];
                bas[ funcpos_altsquare( d, i, j : type := "Sp" )] := vec;
            else
                // type eifi - enfn handled as in the H-type vectors above                
                vec := ZV0; vec[ddH+i0] := 1; vec[dd] := -1;
                vec := Coordinates( subsp, vec );
                if pdividesd then Append( ~vec, 0 ); end if;
                vec := &+[ vec[i]*vecs_ex[i] : i in [1..dd]];
                bas[ funcpos_altsquare( d, i, j : type := "Sp" )] := vec;
            end if;
                
        // here we handle H x K type vectors that lie in the tensor product
        // component
        elif i0 in rangeH and j0 in rangeK then
            vec := basT[(i0-1)*dK+j0-ddH];
            bas[ funcpos_altsquare( d, i, j : type := "Sp" )] := vec;

        // in the case of K x H vectors, the same procedure, but multiplying with -1
        elif i0 in rangeK and j0 in rangeH then                                
            vec := basT[(j0-dK-1)*dK+i0-ddH];
            bas[ funcpos_altsquare( d, i, j : type := "Sp" )] := -vec;
        end if;
    end for;
    

    // if pdividesd then we remove the basis element corresponding to e{d-1}f{d-1}
    if pdividesd then
        bas := Remove( bas, funcpos_altsquare( d, dd -1, dd + 2 ));
    end if;
                    
    return Matrix( bas );
end function;


// the following functions tests if a system of bases for H, K, T, wH, and wK is the right one
// up to +-1 scalars.

// THIS FUNCTION NEEDS CHECKING! Is it enough to take one random number?

TestBasisSp := function( basH, basK, basT, wH, wK, g )
    
    // the possible combinations for the scalars
    scalars := [ <a,b,c,d > : a in [1,-1], b in [1,-1], c in [1,-1], 
                 d in [1,-1]]; 
    
    // check all possible combinations of scalars
    for s in scalars do 
        // build the basis
        bas := BuildBasisSp( basH, basK, basT : wH := wH, scalars := [s[1], s[2], s[3], s[4]] );
        // take random element from the group
        // we want one outside of the center
        repeat 
            x0 := Random( g );
        until (x0,Random(g)) ne x0^0;
        // apply basis transform on x0
        x := bas*x0*bas^-1;
        // find preimage of x
        y := __funcAltSquareToSLdq( x : type := "Sp" );
        // check if the result is valid
        if Category( y ) eq BoolElt then continue; end if;
        // find image of y and check if result is valid
        x1 := __funcSLdqToAltSquare( y : type := "Sp" );
        if Category( x1 ) eq BoolElt or not IsInvertible( x1 ) then continue; end if;
        // x should be x1 if the scalars are right
        if x eq x1  then
            return true, s;
        end if;
    end for;
    
    return false, _;
end function;
    
// a part of the basis calculated in the main function might need to be multiplied by a scalar
// this is done in this function 
find_scalar_for_mT := procedure( G, ~tr, dim, dH, q )

    p12 := funcpos_altsquare( dim, 1, 2 );
    p13 := funcpos_altsquare( dim, 1, dH+1 );
    p23 := funcpos_altsquare( dim, 2, dH+1 );
    p14 := funcpos_altsquare( dim, 1, dH+2 );
    p34 := funcpos_altsquare( dim, dH+1, dH+2 );

    repeat
        x := tr*Random( G )*tr^-1;
        mat1 := Matrix( GF( q ), 3, 3, [
                        x[p12,p12],    x[p12,p13],    x[p12,p23],
                        x[p13,p12],    x[p13,p13],    x[p13,p23],        
                        x[p23,p12],    x[p23,p13],    x[p23,p23]] );
        
        mat2 := Matrix( GF( q ), 3, 3, [
                        x[p13,p13],    x[p13,p14],    x[p13,p34],
                        x[p14,p13],    x[p14,p14],    x[p14,p34],        
                        x[p34,p13],    x[p34,p14],    x[p34,p34]] );
        
        if Determinant( mat1 ) eq 0 or Determinant( mat2 ) eq 0 then 
            mm1 := ZeroMatrix( GF( q ), 3 );
            mm1 := ZeroMatrix( GF( q ), 3 );
        else
            mm1 := __funcAltSquareToSLdq( mat1 ); 
            mm2 := __funcAltSquareToSLdq( mat2 );
        end if;
                        
    until mm1[1,1] ne 0 and mm1[1,3] ne 0;

    assert mm1[1,1] eq mm2[1,1];
    
    lambdasq := mm1[1,3]/mm2[1,2]; 
    is_sq, lambda := IsSquare( lambdasq );
    
    if is_sq then 
      for i in [1..dH], j in [dH+1..dim] do
            pij := funcpos_altsquare( dim, i, j ); tr[pij] := lambda*tr[pij];
       end for; 
    else 
      z0 := PrimitiveElement( GF( q ));
      lambda := Sqrt( z0*lambdasq );
      for i in [1..dH], j in [dH+1..dim] do
            pij := funcpos_altsquare( dim, i, j ); tr[pij] := lambda*tr[pij];
      end for;
    
      for i in [dH+1..dim], j in [i+1..dim] do
            pij := funcpos_altsquare( dim, i, j );
            tr[pij] := z0*tr[pij];
      end for;
    end if; 
end procedure;

/*
SpDecompositionMatrix := function( d1, d2, q )
    
    d := d1 + d2;
    dd := d div 2; dd1 := d1 div 2; dd2 := d2 div 2;

    F := GF( q );
    _, p := IsPrimePower( q );
    mat := ZeroMatrix( GF( q ), d, d );

    for i in [1..d] do 
*/
