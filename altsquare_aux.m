/* 
    sp_aux.m                                                                      RecogniseSmallDim

    This file contains some auxiliary functions necessary for the recognition of exterior squares of 
    for Sp(n,q).

    Written by Csaba Schneider.
    Analysed in February - March, 2024
*/

import "smalldimreps.m":funcpos_altsquare, SolveAltSquareDimEq, __funcAltSquareToSLdq, __funcSLdqToAltSquare;

/* 
    This file contains some auxiliary functions that are necessary for the recognition of the exterior square 
    representations, especially in the case of the symplectic groups. 

    Suppose that M is the large irreducible factor of the exterior square of V where V is the natural module for the 
    symplectic group. Suppose that V = U + W is a decomposition of V into the direct sum of non-degenerate subspaces 
    and also assume that the characteristic p does not divide dim U and dim V. Suppose that C is the 
    stabilizer of the decomposition, and so C = Sp(U) x Sp(W).

    If the characteristic p does not devide dim V, then 

    M = H + K + T + W

    where H and K are the large irreducible quotients of Lambda^2 U and Lambda^2 W, respectively and T = U tensor W. 
    Furthermore, H + W = Lambda^2 U and K + W = Lambda^2 W.

    if p divides dim V, then 

    M = H + K + W

    where H and K are the large irreducible quotients of Lambda^2 U and Lambda^2 W, respectively and T = U tensor W.

*/


/*
    Suppose that n = d1+d2, e1,...,en are the standard row basis vectors of F^n. This function builds a matrix whise rows are 
    
    e1-ed1, e2-ed1, ...,e{d1-1}-ed1, e1+e2+...+ed1      and 
    e{d1+1}-en, e{d1+2}-edn, ...,e{n-1}-en, e{d1+1}+e{d1+2}+...+en.
    
    This is used when e1, e2, etc, represent e1f1, e2f2, ..., enfn and the natural module V is decomposed into components of dimension 
    d1 and d2.
*/


SpTransformMatrix := function( d1, d2, F )
    
    d := d1+d2;
    assert IsEven( d );
    dd1 := d1 div 2; dd2 := d2 div 2; dd := d div 2;
    
    M := ZeroMatrix( F, d div 2, d div 2 );
    
    for i in [1..dd1-1] do
        M[i,i] := 1; M[i,dd1] := -1;
    end for;
    
    for i in [1..dd1] do
        M[dd1,i] := 1;
    end for;
    
    for i in [1..dd2-1] do
        M[dd1+i,dd1+i] := 1; M[dd1+i,dd] := -1;
    end for;
    
    for i in [1..d2 div 2] do
        M[dd,(dd1 + i)] := 1;
    end for;
    
    return M;
end function; 
    
/* 
    Returns the vector space generated by the rows of the matrix in the previous function.

    If pdividesd is true, then returns the vector space generated by the 
    first d1/2 - 1 elemenets
    the elements with index d1/2+1 to d, and 
    the sum of the d1/2 and d/2 entry.
*/

SpSubspace := function( d1, d2, F : pdividesd := false )    

    d := d1 + d2;
    dd1 := d1 div 2; dd2 := d2 div 2; dd := d div 2;
    mat := SpTransformMatrix( d1, d2, F );
    V := VectorSpace( F, dd );
    if pdividesd then
        return VectorSpaceWithBasis( mat[1..dd1-1] cat mat[dd1+1..dd-1] cat [ mat[dd1]+mat[dd]]);
    else  
        return VectorSpaceWithBasis( mat );
    end if;

end function;
    
/* Builds standard basis for V given standard bases for H, K and 
   T = H tensor K */
            
BuildBasis := function( basH, basK, basT : wH, scalars := [1,1,1,1] )

    a := scalars[1]; b := scalars[2]; c := scalars[3];
    d := scalars[4]; 
              
    q := #Field( Parent( basH[1] ));
    _, p := IsPrimePower( q );
    
    for v in [1..#basH] do
        basH[v] := a*basH[v];
    end for;
    
    for v in [1..#basK] do
        basK[v] := b*basK[v];
    end for;
    
    for v in [1..#basT] do
        basT[v] := c*basT[v];
    end for;
    
    if not Category( wH ) eq BoolElt then
        bone1 := d*wH;
    end if;
    
    bas := [];
              
    dH := SolveAltSquareDimEq( #basH : type := "Sp" ); 
    dK := SolveAltSquareDimEq( #basK : type := "Sp" );
    d := dH + dK;
    pdividesd := d mod p eq 0;
    rangeH := [1..dH/2] cat [dH/2+dK+1..d];
    rangeK := [dH/2+1..dH/2+dK];
    
    trmat := SpTransformMatrix( dH, dK, GF( q )); 
    subsp := SpSubspace( dH, dK, GF( q ) : pdividesd := (d mod p) eq 0 );
    vecs_ex := [ basH[ funcpos_altsquare( dH, i, dH-i+1 : type := "Sp" )] :
                 i in [1..dH/2-1]];
    
    if not pdividesd then
        vecs_ex := vecs_ex cat [ bone1 ];
    end if;
    
    vecs_ex := vecs_ex cat [ basK[ funcpos_altsquare( dK, i, dK-i+1 : 
                       type := "Sp" )] : i in [1..dK/2-1]];
    
    if not pdividesd then
        vecs_ex := vecs_ex cat [ -bone1 ];
    else
        vecs_ex := vecs_ex cat [ 0*bone1 ];
        vecs_ex := vecs_ex cat [ 0*bone1 ];
    end if;
    
    for i in [1..d] do
        for j in [i+1..d] do
            i0 := i; j0 := j;
            if <i0,j0> eq <d div 2,d div 2+1> then
                continue j;
            end if;
            if i0 in rangeH and j0 in rangeH then
                
                if i0 gt dH/2 then
                    i0 := i0 - dK;
                end if;
                
                if j0 gt dH/2 then
                    j0 := j0 - dK;
                end if;
                
                if i0+j0 ne dH+1 then
                    
                    vec := basH[ funcpos_altsquare( dH, i0, j0 : 
                                   type := "Sp" )];
                    bas[ funcpos_altsquare( d, i, j : type := "Sp" )] := vec;
                    
                else
                    
                    V := VectorSpace( GF( q ), d div 2 );
                    vec := Zero( V );
                    vec[i0] := 1; vec[d div 2] := -1;
                    // vec := vec*trmat^-1;
                    vec := Coordinates( subsp, vec );
                    if pdividesd then Append( ~vec, 0 ); end if;
                    vec := &+[ vec[i]*vecs_ex[i] : i in [1..d/2]];
                    bas[ funcpos_altsquare( d, i, j : type := "Sp" )] := vec;
                    
                end if;
                
            elif i0 in rangeK and j0 in rangeK then
                
                i0 := i0 - dH div 2;
                j0 := j0 - dH div 2;
                if i0 + j0 ne dK +1 then
                    
                    vec := basK[ funcpos_altsquare( dK, i0, j0 : 
                                   type := "Sp" )];
                    bas[ funcpos_altsquare( d, i, j : type := "Sp" )] := vec;
                    
                else
                    V := VectorSpace( GF( q ), d div 2 );
                    vec := Zero( V );
                    vec[dH div 2+i0] := 1; vec[ d div 2 ] := -1;
                    
                    //vec := vec*trmat^-1;
                    vec := Coordinates( subsp, vec );
                    if pdividesd then Append( ~vec, 0 ); end if;
                    vec := &+[ vec[i]*vecs_ex[i] : i in [1..d/2]];
                    bas[ funcpos_altsquare( d, i, j : type := "Sp" )] := vec;

                end if;
                
            elif i0 in rangeH and j0 in rangeK then
                
                vec := basT[(i0-1)*dK+j0-dH div 2];
                bas[ funcpos_altsquare( d, i, j : type := "Sp" )] := vec;
                
            elif i0 in rangeK and j0 in rangeH then
                                
                vec := basT[(j0-dK-1)*dK+i0-dH div 2];
                bas[ funcpos_altsquare( d, i, j : type := "Sp" )] := -vec;
                
            end if;
        end for;
    end for;
    
    if d mod p eq 0 then
        bas := Remove( bas, 
        funcpos_altsquare( d, (d div 2) -1, (d div 2) + 2 ));
    end if;
                    
    return Matrix( GF( q ), #bas, #bas, [ [ y[i] : i in [1..#bas]] 
                   : y in bas ]);
end function;

TestBasis := function( basH, basK, basT, wH, wK, g )
    
    scalars := [ <a,b,c,d > : a in [1,-1], b in [1,-1], c in [1,-1], 
                 d in [1,-1]]; 
    results := [];
    maxzero := 0;
    
    for s in scalars do 
        bas := BuildBasis( basH, basK, basT : wH := wH,
                       scalars := [s[1], s[2], s[3], s[4]] );
        x0 := Random( g );
        try
          x := bas*x0*bas^-1;
          y := __funcAltSquareToSLdq( x : type := "Sp" );
          x1 := __funcSLdqToAltSquare( y : type := "Sp" );
          if x*x1^-1 eq x^0 then
              //print s[1], s[2], s[3], s[4], s[5];
              Append( ~results, true );
              return true, s;
          else 
              Append( ~results, false );
              els := Eltseq( x-x1 );
              poszero := #[ els[x] : x in [1..#els] | els[x] eq 0 ];
              if poszero gt maxzero then
                 maxzero := poszero;
                 maxs := s;
              end if;
          end if;
                            
          catch e 
            Append( ~results, false );
      end try;
    end for;
    
    return true in results, maxs, maxzero;
end function;
    
// a part of the basis calculated in the main function might need to be multiplied by a scalar
// this is done in this function 
find_scalar_for_mT := procedure( G, ~tr, dim, dH, q )

    p12 := funcpos_altsquare( dim, 1, 2 );
    p13 := funcpos_altsquare( dim, 1, dH+1 );
    p23 := funcpos_altsquare( dim, 2, dH+1 );
    p14 := funcpos_altsquare( dim, 1, dH+2 );
    p34 := funcpos_altsquare( dim, dH+1, dH+2 );

    repeat
        x := tr*Random( G )*tr^-1;
        mat1 := Matrix( GF( q ), 3, 3, [
                        x[p12,p12],    x[p12,p13],    x[p12,p23],
                        x[p13,p12],    x[p13,p13],    x[p13,p23],        
                        x[p23,p12],    x[p23,p13],    x[p23,p23]] );
        
        mat2 := Matrix( GF( q ), 3, 3, [
                        x[p13,p13],    x[p13,p14],    x[p13,p34],
                        x[p14,p13],    x[p14,p14],    x[p14,p34],        
                        x[p34,p13],    x[p34,p14],    x[p34,p34]] );
        
        if Determinant( mat1 ) eq 0 or Determinant( mat2 ) eq 0 then 
            mm1 := ZeroMatrix( GF( q ), 3 );
            mm1 := ZeroMatrix( GF( q ), 3 );
        else
            mm1 := __funcAltSquareToSLdq( mat1 ); 
            mm2 := __funcAltSquareToSLdq( mat2 );
        end if;
                        
    until mm1[1,1] ne 0 and mm1[1,3] ne 0;

    assert mm1[1,1] eq mm2[1,1];
    
    lambdasq := mm1[1,3]/mm2[1,2]; 
    is_sq, lambda := IsSquare( lambdasq );
    
    if is_sq then 
      for i in [1..dH], j in [dH+1..dim] do
            pij := funcpos_altsquare( dim, i, j ); tr[pij] := lambda*tr[pij];
       end for; 
    else 
      z0 := PrimitiveElement( GF( q ));
      lambda := Sqrt( z0*lambdasq );
      for i in [1..dH], j in [dH+1..dim] do
            pij := funcpos_altsquare( dim, i, j ); tr[pij] := lambda*tr[pij];
      end for;
    
      for i in [dH+1..dim], j in [i+1..dim] do
            pij := funcpos_altsquare( dim, i, j );
            tr[pij] := z0*tr[pij];
      end for;
    end if; 
end procedure;
