/* file to contain auxiliary functions for the sym square recognition
   RECALL: the standard basis for the symmetric product space of <e1,...,ed> is 
   e1e1,...,e1ed,e2e2,...,e2ed,...eded. */

import "smalldimreps.m":funcpos_symsquare, funcposinv_symsquare, 
  SolveSymSquareDimEq, BasisMatrixForSymSquareOmega, 
  GetValueOmegaMinus;

import "smalldimreps.m":__funcSymSquareToSLdq, __funcSLdqToSymSquare;
basisfromcomprecf := recformat< bas : AlgMatElt, vals : SeqEnum >;

// the symmetric product of two vectors

SymProd := function( vec1, vec2 )

    d := Dimension( Parent( vec1 ));
    vec := [ 0*vec1[1] : x in [1..d*(d+1)/2]];
    for i in [1..d] do
        for j in [1..d] do
            a := vec1[i]*vec2[j];
            if a ne 0 then 
                pos := funcpos_symsquare( d, i, j );
                vec[pos] := vec[pos]+a;
            end if;
        end for;
    end for;

    return vec;
end function;

// the basis of the sym square of the space generated by <bas>.

SymSquareBasis := function( bas )

    mat := [];
    F := CoefficientRing( Parent( bas[1] ));
    for i in [1..#bas] do
        for j in [i..#bas] do
            Append( ~mat, SymProd( bas[i], bas[j] ));
        end for;
    end for;

    return Matrix( F, #mat, #mat[1], mat );
end function;


// the basis of the tensor product of the spaces generated by <bas1> and <bas2>.

TensorProdBasis := function( bas1, bas2 )
    
    mat := [];
    F := CoefficientRing( Parent( bas1[1] ));

    for b1 in bas1 do
        for b2 in bas2 do
            Append( ~mat, SymProd( b1, b2 ));
        end for;
    end for;

    return Matrix( F, #mat, #mat[1], mat );
end function;

/* The following function splits a (d1+d1)-dimensional space of type <type> into 
   the sum of a d1- and a d2-dimensional spaces of type <typeh> and <typek>
   respectively. */ 

SplitClassicalSpaceIntoComponents := function( d1, d2, F, type : 
                                                ww := 1/2, // (w,w) when typek = Omega 
                                                typeh, 
                                                typek )
    d := d1+d2;
    q := #F;
    V := VectorSpace( F, d );

    if type eq "Omega" and typeh eq "Omega-" then 
    
        i1 := d1 div 2; i2 := (d1+d2) div 2 + 1; i3 := d1 div 2+d2+1;
        v1 := V.i1; v2 := V.i2; v3 := V.i3;
    
        W := sub< V | v1, v2, v3 >;

        mat := ClassicalForms( OmegaMinus( 4, q ))`bilinearForm;

        w2w2 := ClassicalForms( OmegaMinus( 4, q ))`bilinearForm[3,3];

        f3 := ZeroMatrix( F, 3, 3 );
        f3[1,1] := 1;
        f3[3,3] := w2w2;
        f3[2,2] := ww;

        _formf3 := function( u, v )
            return u[1]*v[3]+1/2*u[2]*v[2]+u[3]*v[1];
        end function;
        
        tr := TransformForm( f3, "orthogonalcircle" );

        while (tr[3,1] eq 0 and tr[3,3] eq 0) or tr[2,2] eq 0 do
            tr := tr*Random( GO( 3, q ));
        end while;

        w1 := tr[1,1]*V.i1+tr[1,2]*V.i2+tr[1,3]*V.i3; 
        w2 := tr[2,1]*V.i1+tr[2,2]*V.i2+tr[2,3]*V.i3; 
        w3 := tr[3,1]*V.i1+tr[3,2]*V.i2+tr[3,3]*V.i3;

        bas1 := [ V.i : i in [1..d1 div 2 - 1]] cat [w1,w3] cat 
                [ V.i : i in [d-d1 div 2 + 2 .. d]];
        bas2 := [ V.i : i in [d1 div 2+1 .. d div 2 ]] cat [w2] cat 
                [ V.i : i in [d div 2 + 2 .. d-d1 div 2 ]];
    
    elif type eq "Omega+" and typeh eq "Omega-" then 

        // should only occur when q is cong to 3 mod 4
        assert q mod 4 eq 3;
        mid := d div 2;
        
        /* we have to produce vectors w1, w2, z1, z1 such that 
           (wi,wj) = (zi,zj) = delta_{ij} and <w1,w2> is orthogonal to <z1,z2> */

        // w1 is e_mid + (1/2)f_mid -- w2 is e_{m-d-1}+1/2*f_(mid-1)
        w1 := V.mid+(1/2)*V.(mid+1); w2 := V.(mid-1)+(1/2)*V.(mid+2);

        /* choose gamma, delta, delta1, gamma1  such that 
           gamma1 = -gamma
           delta1 = delta
           delta^2 + gamma^2 = delta1^2 + gamma1^2 = -1/4
           delta*delta1+gamma*gamma1 = delta*gamma+delta1*gamma1 = 0. 
           
           It turns out that the following is a solution of these equations. */
        
        delta := Sqrt( F!(-1/8) ); gamma := delta;
        delta1 := delta; gamma1 := -gamma;
        
        //gamma1 := -gamma; delta1 := delta;

        assert gamma^2+delta^2 eq -1/4 and gamma1^2 + delta1^2 eq -1/4 and 
                gamma*gamma1+delta*delta1 eq 0 and gamma*delta+gamma1*delta1 eq 0;

        //gamma1 := Sqrt( -1/4/(gamma^2/delta^2+1));
        //delta1 := gamma*gamma1/delta;
        z1 := -2*delta*V.(mid-1)-2*gamma*V.mid+gamma*V.(mid+1)+delta*V.(mid+2);
        z2 := -2*delta1*V.(mid-1)-2*gamma1*V.mid+gamma1*V.(mid+1)+delta1*V.(mid+2);

        bas1 := [ V.i : i in [1..d1 div 2 -1 ]] cat [z1,z2] cat 
                [ V.i : i in [d-d1 div 2 + 2 .. d]];
        bas2 := [ V.i : i in [d1 div 2 .. mid - 2 ]] cat [w1,w2] cat 
                [ V.i : i in [mid +3 .. d-d1 div 2 +1]];

    else 

        bas1 := [ V.i : i in [1..d1 div 2 ]] cat [ V.i : i in [d-d1 div 2 + 1 .. d]];
        bas2 := [ V.i : i in [d1 div 2+1 .. d-d1 div 2 ]];

    end if;

    return bas1, bas2;
end function;

// the value of the standard form of ort__circle

_st_ort_form_circle := function( d, i, j )
            
    if i+j eq d+1 and i ne (d+1) div 2 then 
        return 1;
    elif i eq (d+1) div 2 and j eq (d+1) div 2 then
        return 1/2;
    else 
        return 0;
    end if;
end function;

// the value of the standard form on the symmetric square of a space of type ort__circle

_st_formsymsquare_orth_circle := function( d, u, v )
            
    a := 0;

    for i in [1..d*(d+1)/2] do 
        for j in [1..d*(d+1)/2] do 
            if u[i] ne 0 and v[j] ne 0 then 
                pi := funcposinv_symsquare( d, i );
                pj := funcposinv_symsquare( d, j );
                a := a+u[i]*v[j]*( _st_ort_form_circle( d, pi[1], pj[1] )*
                _st_ort_form_circle( d, pi[2], pj[2] ) + 
                _st_ort_form_circle( d, pi[1], pj[2] )*
                _st_ort_form_circle( d, pi[2], pj[1] ))/2;
            end if;
        end for;
    end for;

    return a;
end function;

// the value of the standard form of ort_plus

_st_ort_form_plus := func< d, i, j |
        case< i+j eq d+1 | true: 1, false: 0, default: -1 >>;

// the value of the standard form on the symmetric square of a space of type ort__plus

_st_formsymsquare_orth_plus := function( d, u, v )
            
    a := 0;

    for i in [1..d*(d+1)/2] do 
        for j in [1..d*(d+1)/2] do 
            if u[i] ne 0 and v[j] ne 0 then 
                pi := funcposinv_symsquare( d, i );
                pj := funcposinv_symsquare( d, j );
                a := a+u[i]*v[j]*( _st_ort_form_plus( d, pi[1], pj[1] )*
                _st_ort_form_plus( d, pi[2], pj[2] ) + 
                _st_ort_form_plus( d, pi[1], pj[2] )*
                _st_ort_form_plus( d, pi[2], pj[1] ))/2;
            end if;
        end for;
    end for;

    return a;
end function;


/*
  Suppose that V is s classical space and U and W are two non-degenerate subspaces. Then 
  the symmetric square of V can be written as the sum  
  SymSquare( U ) + SymSquare( W ) + TensorProduct( U, W ). 
  This function constructs a basis for V that contains bases for these components.

  Note that the sum above is direct unless V is orthogonal. In this case, O(V) is not 
  irreducible on SymSquare( V ) and we work with the large composition factor of
  codimension 1 (when the characteristic does not divide the dimension of V) or 2 (otherwise). 
  
  In the orthogonal case, SymSquare( U ) meet SymSquare( W ) is one dimensional a 
  generator is inserted at the end of the basis.

  The complications arise when V is an orthogonal type, since in this case U and W are 
  also of orthogonal type, but thet can have subtype different from the type of V. 
*/ 

AssignBasisFromComponents := procedure( ~G, d1, d2, F : 
                                    ww := 1/2, // this is needed when typek is Omega
                                    type, // the type of V
                                    typeh, // the type of U
                                    typek )// the type of W
    

    bas1, bas2 := SplitClassicalSpaceIntoComponents( d1, d2, F, type : 
                                                     ww := ww, 
                                                     typeh := typeh, 
                                                     typek := typek );
    basH := SymSquareBasis( bas1 );
    basK := SymSquareBasis( bas2 );
    basT := TensorProdBasis( bas1, bas2 );

    dH := NumberOfRows( basH );
    dK := NumberOfRows( basK );
    dT := NumberOfRows( basT );

    if type in {"Omega+","Omega-","Omega"} then 
        bom := BasisMatrixForSymSquareOmega( typeh, #bas1, F ); 
        boc := BasisMatrixForSymSquareOmega( typek, #bas2, F : ww := ww );
        basH := [&+[ bom[i,j]*basH[j] : j in [1..dH]] : i in [1..dH]];
        basK := [&+[ boc[i,j]*basK[j] : j in [1..dK]] : i in [1..dK]];
    
        bas := basH[1..dH-1] cat basK[1..dK-1] cat basT[1..dT] cat [basH[dH]] cat 
            [basK[dK]];
    else 
        bas := basH[1..dH] cat basK[1..dK] cat basT[1..dT];
    end if;

    if type eq "Omega" and typeh eq "Omega-" then
        a := Zero( Parent( basH[1] ));
        d := d1+d2;
        a[d] := 1; a[funcpos_symsquare( d, (d+1) div 2, (d+1) div 2 )] := -2;
        aa := _st_formsymsquare_orth_circle( d, a, a );
        awH := _st_formsymsquare_orth_circle( d, a, basH[#basH] );
        awK := _st_formsymsquare_orth_circle( d, a, basK[#basK] );
        wHwH := _st_formsymsquare_orth_circle( d, basH[#basH], basH[#basH] );
        wKwK := _st_formsymsquare_orth_circle( d, basK[#basK], basK[#basK] );
    elif type eq "Omega+" and typeh eq "Omega-" then
        a := Zero( Parent( basH[1] ));
        d := d1+d2;
        a[d] := 1; a[funcpos_symsquare( d, d div 2, d div 2 + 1 )] := -1;
        aa := _st_formsymsquare_orth_plus( d, a, a );
        awH := _st_formsymsquare_orth_plus( d, a, basH[#basH] );
        awK := _st_formsymsquare_orth_plus( d, a, basK[#basK] );
        wHwH := _st_formsymsquare_orth_plus( d, basH[#basH], basH[#basH] );
        wKwK := _st_formsymsquare_orth_plus( d, basK[#basK], basK[#basK] );  
    else 
        aa := 0; awH := 0; awK := 0; wHwH := 0; wKwK := 0;            
    end if;
    
    bas := Matrix( F, dH+dK+dT, dH+dK+dT, [ Eltseq( x ) : x in bas ]);
    G`BasisMatrixFromComponents := rec< basisfromcomprecf | 
                                bas := bas, vals := [ aa, awH, awK, wHwH, wKwK ]>;

end procedure;

OmegaBasisFromComponents := function( G )

    return G`BasisMatrixFromComponents`bas, G`BasisMatrixFromComponents`vals;
end function; 

/* this function determines the orthogonal type of the large component of the 
    symmetric square of Omega*( d, q ) */

TypeOfSymSquareOmega := function( type, d, q )

    if (type eq "Omega" and IsEven( d )) or 
        (type in {"Omega+", "Omega-"} and IsOdd( d )) then 
        return "false";
    end if;

    _, p := IsPrimePower( q );
    nrrows := case< type  |
        "Omega+": d div 2 - 1, "Omega-": d div 2+1, 
        "Omega": (d-1) div 2, default: false >;

    if d mod p eq 0 then nrrows := nrrows - 1; end if;

    if IsOdd( nrrows ) then 
        return "orthogonalcircle";
    end if; 

    if type eq "Omega+" then 
        a := 1/2; b := 1;
    elif type eq "Omega-" then
        x := GetValueOmegaMinus( GF( q )); 
        cf := ClassicalForms( OmegaMinus( 4, GF( q )))`bilinearForm;
        a := x^2*cf[3,3]^2;
        b := (1/2+x^2*cf[3,3]^2);
        c := (cf[2,2]^2+x^2*cf[3,3]^2);
    elif type eq "Omega" then 
        a := 1;
        b := 3/2;
    end if;

    mat := [ a : x in [1..nrrows^2]];
    mat := Matrix( GF( q ), nrrows, nrrows, mat );
    for i in [1..nrrows] do
        mat[i,i] := b;
    end for;

    if type eq "Omega-" then 
        mat[nrrows-1,nrrows-1] := c;
        for i in [1..nrrows-1] do
            mat[i,nrrows] := 0; mat[nrrows,i] := 0;
        end for;
        mat[nrrows,nrrows] := (cf[2,2]*cf[3,3]/2);
    end if;

    tr := TransformBilinearForm( mat );
    if tr[nrrows div 2, nrrows div 2] eq 0 then
        return "orthogonalplus";
    else
        return "orthogonalminus";
    end if;

end function;


BuildBasisOmega := function( G, basH, basK, basT : type := "Omega+", 
                                                typeh := "Omega+",
                                                typek := "Omega+", 
                                                wH, wK, 
                                                scalars := [1,1,1,1],
                                                ww := 1/2 )

    dH := SolveSymSquareDimEq( #basH : type := typeh ); 
    dK := SolveSymSquareDimEq( #basK : type := typek );

    a := scalars[1]; b := scalars[2]; c := scalars[3];
    d := scalars[4]; 
    if Category( wH ) ne BoolElt and Category( wK ) eq BoolElt then 
        wK := -wH; 
    end if;
              
    q := #Field( Parent( basH[1] ));
    _, p := IsPrimePower( q );
    
    for v in [1..#basH] do
        basH[v] := a*basH[v];
    end for;
    
    for v in [1..#basK] do
        basK[v] := b*basK[v];
    end for;
    
    for v in [1..#basT] do
        basT[v] := c*basT[v];
    end for;
    
    if Category( wH ) ne BoolElt then
        wH := d*wH; wK := d*wK;
    end if;

    basall := basH cat basK cat basT;
    if Category( wH ) ne BoolElt then 
        basall := basall cat [ wH ] cat [ wK ];
    end if;
    mat := OmegaBasisFromComponents( G );
                
    if type in {"SL", "Sp", "SU"} then 
        M0 := IdentityMatrix( GF( q ), (dH+dK)*(dH+dK+1) div 2 );
        mat := M0*mat^-1; 
        bas := [ &+[ mat[i,j]*basall[j] : j in [1..#basall]] : i in [1..#basall]];
    else 
        M0 := BasisMatrixForSymSquareOmega( type, dH+dK, GF( q ));
        mat := M0*mat^-1; 
        bas := [ &+[ mat[i,j]*basall[j] : j in [1..#basall]] : i in [1..#basall-1]];
    end if;

    if Category( wH ) ne BoolElt and wH eq 0*wH then
        bas := Matrix( GF( q ), #bas-1, #basall-2, [ bas[i,j] : j in [1..#basall-2], 
                i in [1..#bas-1]] );
    elif Category( wH ) ne BoolElt then 
        bas := Matrix( GF( q ), #bas, #basall-1, [ bas[i,j] : j in [1..#basall-1], 
                i in [1..#bas]] );
    else 
        bas := Matrix( GF( q ), #bas, #basall, [ bas[i,j] : j in [1..#basall], 
                                             i in [1..#bas]] );
    end if;
    
    return bas;
end function;


TestBasisOmega := function( G, basH, basK, basT, wH, wK, g : type := "Omega+", 
                                                          typeh := "Omega+", 
                                                          typek := "Omega+",
                                                          ww := ww )

    F := CoefficientRing( g );    
    scalars := [ <a,b,c,d > : a in [1,-1], b in [1,-1], c in [1,-1], 
                 d in [ 1,-1 ]]; 
    results := [];
    maxzero := 0;
    for s in scalars do 
        bas := BuildBasisOmega( G, basH, basK, basT : wH := wH, 
                                              type := type,
                                              typeh := typeh,
                                              typek := typek,
                                 scalars := [s[1], s[2], s[3], s[4]], ww := ww );
        x0 := Random( g );
        try
          x := bas*x0*bas^-1;
          y := __funcSymSquareToSLdq( x : type := type );
          x1 := __funcSLdqToSymSquare( y : type := type );
          if x*x1^-1 eq x^0 then
              Append( ~results, true );
              return true, s;
          else 
              Append( ~results, false );
              els := Eltseq( x-x1 );
              poszero := #[ els[x] : x in [1..#els] | els[x] eq 0 ]; 
              if poszero gt maxzero then
                 maxzero := poszero;
                 maxs := s;
              end if;
          end if;
                            
          catch e 
            Append( ~results, false );
      end try;
    end for;
    
    return true in results, maxzero;
end function;