/* The following function performs AltSquare recognition by recognising
   the tensor component and recovering the smaller alt square components 
   directly from the tensor factor. It does not use recursive call and it
   may perform better for certain inputs. 

   This version is the implementation of non-SL classical group */
  
   
import "smalldimreps.m":SolveAltSquareDimEq, funcpos_altsquare, 
  __funcSLdqToAltSquare, __funcAltSquareToSLdq;

import "auxfunctions.m": MyDerivedGroupMonteCarlo, IsSimilarModMinus1List, 
  IsSimilarModScalar, SplitTensor, RandomInvolution, InvolutionWithProperty,
  IsSimilarToScalarMultiple, ConjugateClassicalStandardToSXnq;

/* The recognition procedure for the exterior square representations
  of the classical groups. */
  
  
BuildBasis := function( basH, basK, basT, wH :
                        scalars := [1,1,1,1] )
              
    a := scalars[1]; b := scalars[2]; c := scalars[3];
    d := scalars[4]; 
              
    q := #Field( Parent( basH[1] ));
    
    for v in [1..#basH] do
        basH[v] := a*basH[v];
    end for;
    
    for v in [1..#basK] do
        basK[v] := b*basK[v];
    end for;
    
    for v in [1..#basT] do
        basT[v] := c*basT[v];
    end for;
    
    bone1 := d*wH;
    
    v45 := (-basK[3]-bone1)/2;
    v18 := (basH[3]+bone1)/2;
    v27 := (-basH[3]+bone1)/2;
   
    bas := [];
    
    bas[1] := basH[1];   //12
    bas[2] := basT[1];   //13
    bas[3] := basT[2];   //14
    bas[4] := basT[3];   //15
    bas[5] := basT[4];   //16
    bas[6] := basH[2];   //17
    bas[7] := v18-v45;   //18-45=(18-27+18+27)/2-45
    bas[8] := basT[5];   //23
    bas[9] := basT[6];   //24
    bas[10] := basT[7];  //25                  
    bas[11] := basT[8];  //26
    bas[12] := v27-v45;  //27-45=(-18+27+18+27)/2-45 
    bas[13] := basH[4];   //28    
    bas[14] := basK[1];   //34
    bas[15] := basK[2];   //35 
    bas[16] := basK[3];   //36-45
    bas[17] := -basT[9];  //37
    bas[18] := -basT[13]; //38
    bas[19] := basK[4];   //46
    bas[20] := -basT[10]; //47
    bas[21] := -basT[14]; //48
    bas[22] := basK[5];   //56
    bas[23] := -basT[11]; //57
    bas[24] := -basT[15]; //58
    bas[25] := -basT[12]; //67
    bas[26] := -basT[16]; //68
    bas[27] := basH[5];   //78
      
    tr := MatrixAlgebra( GF( q ), 27 )![ Eltseq( x ) : x in bas ];   
    return tr;
end function;

    
      
RecogniseAltSquareSp8 := function( G : type := "Sp", CheckResult := true )
    
    q := #CoefficientRing( G ); 
    dimg := 27; dim := 8;


    /* find an involution with sufficiently large minus one eigenspace and 
       its centraliser. */
      
    eiglim1 := case< dim | 6: 8, default: (2/9)*dim^2 >; 
    // lower limit for eigenspace dim
    eiglim2 := case< dim | 6: 8, default: (1/4)*dim^2 >; 
    // upper limit for eigenspace dim
    // set up property function for InvolutionWithProperty  
    propfunc := function( x )
        dmin := Dimension( Eigenspace( x, -1 )); 
        return dmin ge eiglim1 and dmin le eiglim2;
    end function;
        
    // completion checking function
    
    NrGensCentInv := 10; 
    __compcheck := func< G, C, g | NumberOfGenerators( C ) ge NrGensCentInv >;
    
    gensC := []; gensCD := [];
    
    /* the following block will find an involution with the right
       minus one eigenspace and sets up its centralizer */      
    
    repeat   
        if not assigned inv then 
            inv := InvolutionWithProperty( G, propfunc );
        end if;
        C := CentraliserOfInvolution( G, inv : 
                     CompletionCheck := __compcheck );  
        CD := MyDerivedGroupMonteCarlo( C : 
                      NumberGenerators := NrGensCentInv,
                      DerivedLength := case< dim | 
                      8: 2, 9: 2, 10: 2, 11: 2, 12: 2, 18: 2, 
                      default : 1 >);     
        gensC := gensC cat GeneratorsSequence( C );
        gensCD := gensCD cat GeneratorsSequence( CD );
        C := sub< Universe( gensC ) | gensC >;
        CD := sub< Universe( gensCD ) | gensCD >;
        
        M := GModule( CD );
        mins := [ x : x in MinimalSubmodules( M : Limit := 4 )];
        
        if #mins eq 2 then 
            delete inv; 
            gensC := [];
            gensCD := [];
        end if; 
    until  #mins eq 4 and &+[ Dimension( x ) : x in mins ] eq dimg;

      /* The C-module V splits into four components.
         There is a one-dimensional component. 
         Two components are isomorphic to the 
         large irreducible factors of alt square U and alt square W, 
         respectively. The third is isomorphic to U tensor W.
         The two alt squares lie in one of the eigenspaces of inv. The tensor 
         lies in the other eigenspace. */
      
    // find which component lies in the minus one or the plus one eigenspace  
    mplus := [ mins[x] : x in [1..4] | 
               (M!mins[x].1)^inv eq M!mins[x].1 and 
               Dimension( mins[x] ) ge 2 ];
    mminus := [ mins[x] : x in [1..4] | 
                (M!mins[x].1)^inv eq -M!mins[x].1 and 
                Dimension( mins[x] ) ge 2 ];
    
    // in the case of Sp, etc, there is a one-dimensional component
    monedim := [ mins[x] : x in [1..4] | Dimension( mins[x] ) eq 1 ][1];
    
    // we select the two irreducible exterior square components
    if #mplus eq 2 then
        mH := mplus[1]; mK := mplus[2]; mT := mminus[1];
    else 
        mH := mminus[1]; mK := mminus[2]; mT := mplus[1];
    end if;      
    
    // set up the variables for the dimensions of H, K and T 
    dimH := Dimension( mH ); dimK := Dimension( mK ); dimT := Dimension( mT );
    dH := SolveAltSquareDimEq( dimH : type := "Sp" ); 
    dK := SolveAltSquareDimEq( dimK : type := "Sp" ); 
    dT := dH*dK;
    assert Dimension( mT ) eq dT;
    
    // set up the projections into the components
    
    ah := pmap< GL( dimg, q ) -> GL( dimH, q ) | 
          x :-> GL( dimH, q )![ Eltseq( mH!((M!b)^x )) : b in Basis( mH )]>;
    
    ak := pmap< GL( dimg, q ) -> GL( dimK, q ) | 
          x :-> GL( dimK, q )![ Eltseq( mK!((M!b)^x )) : b in Basis( mK )]>;
    
    at := pmap< GL( dimg, q ) -> GL( dimT, q ) | 
          x :-> GL( dimT, q )![ Eltseq( mT!((M!b)^x )) : b in Basis( mT )]>;
    
    /* For some technical reason (see (###) later), the projection of a 
       generator of C cannot be similar to its negative and we want that
       the projection by ah and ak should fall into SL.     
       If some generator fails to satisfy this, it is thrown away and is 
       replaced by another one. */  

    mnsh := GL( dimH, q )!ScalarMatrix( GF( q ), dimH, -1 );
    mnsk := GL( dimK, q )!ScalarMatrix( GF( q ), dimK, -1 );
        
    // TODO: check if this is needed in this version. I suspect not.    
        
    for i in [1..#gensCD] do
        if Determinant( gensCD[i]@ah ) ne 1 or 
              Determinant( gensCD[i]@ak ) ne 1 or 
              IsSimilarToScalarMultiple( gensCD[i]@ah ) or
              IsSimilarToScalarMultiple( gensCD[i]@ak ) then
           repeat
               x := Random( CD );
           until Determinant( x@ah ) eq 1 and
                Determinant( x@ak ) eq 1 and not 
                IsSimilarToScalarMultiple( x@ah ) and not
                IsSimilarToScalarMultiple( x@ak );
           gensCD[i] := x;
       end if;
   end for; 
   
   CD:= sub< Universe( gensCD ) | gensCD >;

   /* Construct the image of CD in the tensor product component. It must be 
      isomorphic to the tensor product of the preimages of the 
      groups induced on the alt square components */
      
    genst := [ x@at : x in gensCD ];
    aT := sub< Universe( genst ) | genst >;
    
    v := IsTensor( aT ); assert v; 
    
    // get the dimensions of the tensor factors
    dt1 := Dimension( TensorFactors( aT )[1] ); 
    dt2 := Dimension( TensorFactors( aT )[2] );
    
    /* the dimensions dt1 and dt2 of the tensor factors must be equal to 
       dH and dK in this order. If not, we must swap H and K. */
                                  
    if dt1 ne dH then 
        temp := dH; dH := dK; dK := temp;
        temp := dimH; dimH := dimK; dimK := temp;
        temp := ah; ah := ak; ak := temp;
        temp := mH; mH := mK; mK := temp;
    end if;
    
    // calculate the basis for aT that reflects the tensor structure
    
    tbas := TensorBasis( aT )^-1;
    // set of the maps from aT into the tensor components
    
    ch := pmap< GL( dimg, q ) -> GL( dH, q ) | x :-> SplitTensor( 
                  tbas*x@at*tbas^-1, dK, dH )[2] >;
    
    ck := pmap< GL( dimg, q ) -> GL( dK, q ) | x :-> SplitTensor( 
                  tbas*x@at*tbas^-1, dK, dH )[1] >;
    
    gens1h := [ x@ch : x in gensCD ];
    gens1k := [ x@ck : x in gensCD ];
    
    /* The groups generated by gens1h and gens1k are isomorphic to 
       Sp( dH, q ) and Sp( dK, q ). They need to be conjugated into
       the right copy of Sp( d*, q ) by finding the alternating     
       bilinear form that it preserves. */
      
    /* the groups generated by gens1h and gens1k preseve an alternating
       bilin form modulo +-one. */
    sch := ClassicalForms( sub< Universe( gens1h ) | gens1h > : 
                   Scalars := true )`scalars;
    sck := ClassicalForms( sub< Universe( gens1k ) | gens1k > 
                   : Scalars := true )`scalars;
    
    assert sch eq sck;
    
    // if a generator preseve the form module -1, then this is fixed.
    for i in [1..#sch] do
        if sch[i] eq -1 then
           gens1h[i] := gens1h[i]*ScalarMatrix( GF( q ), dH, 
                             Sqrt( GF( q )!(-1)));
           gens1k[i] := gens1k[i]*ScalarMatrix( GF( q ), dK, 
                                Sqrt( GF( q )!(-1)) );
        end if;
    end for;
    
    /* now sub< gens1h > and sub< gens1k > preserve the form. 
       we calculate the transformation matrices  and conjugate the 
       generators to the right form. */
    Th := TransformForm( sub< Universe( gens1h ) | gens1h > );
    Tk := TransformForm( sub< Universe( gens1k ) | gens1k > );
    
    tbas := TensorProduct( Th^-1, Tk^-1 )*tbas;
    gens1h := [ x^Th : x in gens1h ];
    gens1k := [ x^Tk : x in gens1k ];
    
    /* we calculate the matrices in the irreducible exterior square
       representation of Sp( d, q ) */
      
    gens1h := [ GL(dimH,q)!__funcSLdqToAltSquare( x : type := "Sp") : 
                x in gens1h ];
    gens2h := [ x@ah : x in gensCD ];
    
    gens1k := [ GL(dimK,q)!__funcSLdqToAltSquare( x : type := "Sp" ) : 
                x in gens1k ];
    gens2k := [ x@ak : x in gensCD ];
    
    vh, scalarsh := IsSimilarModScalar( gens1h, gens2h ); 
    
    if vh then
        vk, scalarsk := IsSimilarModScalar( gens1k, gens2k );
        gens2h := [ ScalarMatrix( GF(q), dimH, scalarsh[i] )*
                    gens2h[i] : 
                      i in [1..#gensCD] ];
        gens2k := [ ScalarMatrix( GF(q), dimK, scalarsk[i] )*gens2k[i] : 
                      i in [1..#gensCD] ];                            
    else 
        vh, scalarsh := IsSimilarModScalar( gens1h, gens2k ); 
        vk, scalarsk := IsSimilarModScalar( gens1k, gens2h ); 
        assert vh and vk;
        temp  := gens2h;
        gens2h := [ ScalarMatrix( GF(q), dimK, scalarsh[i] )*gens2k[i] : 
                      i in [1..#gensCD] ];
        gens2k := [ ScalarMatrix( GF(q), dimH, scalarsk[i] )*temp[i] : 
                    i in [1..#gensCD] ];
        temp := dimK; dimK := dimH; dimH := temp;
        temp := mK; mK := mH; mH := temp;       
    end if;
    
    assert vh and vk;
    
    M1H := GModule( sub< GL( dimH, q ) | gens1h >);
    M2H := GModule( sub< GL( dimH, q ) | gens2h >);
    
    v, trmh := IsIsomorphic( M1H, M2H ); assert v;
    
    M1K := GModule( sub< GL( dimK, q ) | gens1k >);
    M2K := GModule( sub< GL( dimK, q ) | gens2k >);
    
    v, trmk := IsIsomorphic( M1K, M2K ); assert v;
    
    // bas1 is [e12,e13,...,e23,...,e{k-1}{k}]
    // bas2 is [e{k+1}{k+2},...,e{d-1}d]
      
    basH := [ M!(&+[trmh[j][i]*Basis( mH )[i] : 
                    i in [1..dimH]]) : j in [1..dimH]];
    
    basK := [ M!(&+[trmk[j][i]*Basis( mK )[i] : 
                    i in [1..dimK]]) : j in [1..dimK]];
    
    basT := [ M!(&+[tbas[j][i]*Basis( mT )[i] : 
                    i in [1..dT]]) : j in [1..dT]];
    
    basOneDim := [ M!(Basis( monedim )[1])];
    
    // we normalize basOneDim
      
    form := ClassicalForms( G )`bilinearForm;
    vH := Sqrt((basH[1]*form*Matrix( 27, 1, basH[5] ))[1])^-1;
    vK := Sqrt((basK[1]*form*Matrix( 27, 1, basK[5] ))[1])^-1;
    vO := Sqrt((basOneDim[1]*form*Matrix( 27, 1, basOneDim[1] ))[1])^-1;
    
    for i in [1..#basH] do 
        basH[i] := vH*basH[i];
        basK[i] := vK*basK[i];
    end for;
    
    basOneDim[1] := 2*vO*basOneDim[1];
    
    return basH, basK, basT, basOneDim, CD;
    
    print (basH[1]*form*Matrix( 27, 1, basH[5] ))[1], 
      (basK[1]*form*Matrix( 27, 1, basK[5] ))[1],
      (basOneDim[1]*form*Matrix( 27, 1, basOneDim[1] ))[1];
    bonedim := basOneDim[1];
    bonedim1 := 4*bonedim;
       
      
    // 13 14 15 16 23 24 25 26 73 74 75 76 83 84 85 86                   
      
    bas := BuildBasis( basH, basK, basT, basOneDim[1], basOneDim[1] );
    bas1 := bas;
      

    p12 := 1; 
    p13 := 2;
    p23 := 8;
    p14 := 3;
    p34 := 13;
    tind := [2,3,4,5,8,9,10,11,17,18,20,21,23,24,25,26];
    
    repeat
        x := bas*Random( G )*bas^-1;
        mat1 := Matrix( GF( q ), 3, 3, [
                        x[p12,p12],    x[p12,p13],    x[p12,p23],
                        x[p13,p12],    x[p13,p13],    x[p13,p23],        
                        x[p23,p12],    x[p23,p13],    x[p23,p23]] );
        
        mat2 := Matrix( GF( q ), 3, 3, [
                        x[p13,p13],    x[p13,p14],    x[p13,p34],
                        x[p14,p13],    x[p14,p14],    x[p14,p34],        
                        x[p34,p13],    x[p34,p14],    x[p34,p34]] );
        
        mm1 := __funcSLdqToAltSquare( mat1 );
        mm2 := __funcSLdqToAltSquare( mat2 );
        
    until Determinant( mat1 ) ne 0 and Determinant( mat2 ) ne 0 and 
          mm1[1,3] ne 0 and mm1[1,1] ne 0 and mm2[1,2] ne 0 and mm2[1,1] ne 0;
    
    mm2 := mm1[1,1]*mm2[1,1]^-1*mm2;
    lambdasq := mm1[1,3]/mm2[1,2];
    
    try 
      lambda := Sqrt( lambdasq );  print lambda;
      print "OK1";
      for i in tind do
          bas[i] := lambda*bas[i];
      end for;
            
      catch e  
        print "exception";
    end try;
  
    tr := MatrixAlgebra( GF( q ), 27 )![ Eltseq( x ) : x in bas ];  
    tr1 := MatrixAlgebra( GF( q ), 27 )![ Eltseq( x ) : x in bas1 ];
                   
    return tr, tr1, CD;
end function;